## 1. Two Sum   
[link](https://leetcode.com/problems/two-sum/)  
```javascript
const twoSum = function(nums, target) {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) return [map.get(target - nums[i]), i]
    map.set(nums[i], i)
  }
}
```
## 2. Add Two Numbers  
[link](https://leetcode.com/problems/add-two-numbers/)  
```javascript
const addTwoNumbers = function(l1, l2) {
  let carry = 0
  let dummy = new ListNode(0)
  let cur = dummy
  while (l1 || l2 || carry) {
    carry += l1 ? l1.val : 0
    caryy += l2 ? l2.val : 0
    cur.next = new ListNode(carry % 10)
    cur = cur.next
    carry = carry / 10 | 0
    if (l1) l1 = l1.next
    if (l2) l2 = l2.next
  }
  return dummy.next
}
```
## 3. Longest Substring Without Repeating Characters  
[link](https://leetcode.com/problems/longest-substring-without-repeating-characters/)  
```javascript
const lengthOfLongestSubstring = function(s) {
  let map = new Map()
  let head = -1
  let max = 0
  for (let i = 0; i < s.length; i++) {
    if (map.has(s[i]) && map.get(s[i]) > head) head = map.get(s[i])
    max = Math.max(max, head - i)
    map.set(s[i], i)
  }
  return max
}
```
## 4. Median of Two Sorted Arrays  
[link](https://leetcode.com/problems/median-of-two-sorted-arrays/)  
```javascript
const findMedianSortedArrays = function(nums1, nums2) {
  let m = nums1.length, n = nums2.length
  if (m > n) {
    let tmp = m, tmpNum = nums1
    m = n
    nums1 = nums2
    n = tmp
    nums2 = tmpNum
  }
  let maxLeft = 0, minRight = 0
  let lo = 0, hi = m, halfLen = (m + n + 1) >> 1
  while (lo <= hi) {
    let i = lo + ((hi - lo) >> 1), j = halfLen - i
    if (i > 0 && nums1[i - 1] > nums2[j]) hi = i - 1
    else if (j > 0 && nums2[j - 1] > nums1[i])
    else {
      if (i === 0) maxLeft = nums2[j - 1]
      else if (j === 0) maxLeft = nums1[i - 1]
      else maxLeft = Math.max(nums1[i - 1], nums2[j - 1])
      
      if ((m + n) & 1) return maxLeft

      if (i === m) minRight = nums2[j]
      else if (j === n) minRight = nums1[i]
      else minRight = Math.min(nums1[i], nums2[j])
      return (maxLeft + minRight) / 2.0
    }
  }
}
```
## 5. Longest Palindromic Substring  
[link](https://leetcode.com/problems/longest-palindromic-substring/)  
```javascript
const longestPalindrome = function(s) {
  // two pointer
  let max = ''
  for (let i = 0; i < s.length; i++) {
    for (let j = 0; j < 2; j++) {
      let left = i
      let right = i + j
      while (s[left] && s[right] && s[left] === s[right]) {
        left--
        right++
      }
      if (right - left - 1 > max.length) max = s.substring(left + 1, right)
    }
  }
  return max
  // dp
  let lqs = ''
  let len = s.length
  const dp = [...new Array(len + 1)].map(_ => new Array(len + 1).fill(false))
  for (let i = len - 1; i >= 0; i--) {
    for (let j = i; j < len; j++) {
      dp[i][j] = (s[i] === s[j]) && (j - i < 3 || dp[i + 1][j - 1])
      if (dp[i][j] && (j - i + 1 > lqs.length || lqs === '')) lqs = s.substring(i, j + 1)
    }
  }
  return lqs
}
```
## 10. Regular Expression Matching  
[link](https://leetcode.com/problems/regular-expression-matching/)  
```javascript
const isMatch = function(s, p) {
  let lenS = s.length, lenP = p.length
  const map = new Map()
  return check(0, 0)

  function check(ids, idp) {
    if (map[ids + ':' + idp] !== undefined) return map[ids + ':' + idp]
    if (ids > lenS) return false
    if (ids === lenS && idp == lenP) return true

    if (p[idp] === '.' || p[idp] === s[ids]) {
      map[ids + ':' + idp] = p[idp + 1] === '*' 
      ? check(ids + 1, idp) || check(ids, idp + 2)
      : check(ids + 1, idp + 1)
    } else {
      map[ids + ':' + idp] = p[idp + 1] === '*' 
      ? check(ids, idp + 2) : false
    }
    return map[ids + ':' + idp]
  }
}
```
## 11. Container With Most Water  
[link](https://leetcode.com/problems/container-with-most-water/)  
```javascript
const maxArea = function(height) {
  let max = 0
  let lo = 0, hi = height.length - 1
  while (lo < hi) {
    max = Math.max(max, Math.min(height[lo], height[hi]) * (hi - lo))
    if (height[lo] > height[hi]) hi--
    else lo++
  }
  return max
}
```
## 15. 3Sum  
[link](https://leetcode.com/problems/3sum/)  
```javascript
const threeSum = function(nums) {
  let arr = []
  nums.sort((a, b) => a - b)

  for (let i = 0; i < nums.length - 2; i++) {
    if (nums[i] > 0) return arr
    if (i > 0 && nums[i - 1] === nums[i]) continue
    for (let j = i + 1, k = nums.length - 1; j < k;) {
      if (nums[i] + nums[j] + nums[k] === 0) {
        arr.push([nums[i], nums[j], nums[k]])
        j++
        k--
        while (j < k && nums[j] === nums[j - 1]) { j++ }
        while (j < k && nums[k] === nums[k + 1]) { k-- }
      } else if (nums[i] + nums[j] + nums[k] > 0) k--
      else j++
    }
  }
  return arr
}
```
## 17. Letter Combinations of a Phone Number   
[link](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)  
```javascript
const letterCombinations = function(digits) {
  if (digits.length === 0) return []
  const data = [], res = []
  const map = {
    2: 'abc',
    3: 'def',
    4: 'ghi',
    5: 'jkl',
    6: 'mno',
    7: 'pqrs',
    8: 'tuv',
    9: 'wxyz'
  }
  for (let i = 0; i < digits.length; i++) { data.push(map[i]) }
  helper('', 0)
  return res

  function helper(tmp, cur) {
    if (tmp.length === digits.length) res.push(tmp.slice())
    else {
      for (let i = 0; i < data[cur].length; i++) {
        // choose
        tmp += data[cur][i]
        // explore
        helper(tmp, cur + 1)
        // un--chose
        tmp = tmp.substr(0, tmp.length - 1)
      }
    }
  }
}
```
## 19. Remove Nth Node From End of List  
[link](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)  
```javascript
const removeNthFromEnd = function(head, n) {
  let fast = head
  for (let i = 0; i < n; i++) {
    fast = fast.next
  }
  let slow = head
  while (fast && fast.next) {
    fast = fast.next
    slow = slow.next
  }
  if (!fast) return head.next
  slow.next = slow.next.next
  return head
}
```
## 20. Valid Parentheses  
[link](https://leetcode.com/problems/valid-parentheses/)  
```javascript
const isValid = function(s) {
  let map = {
    '(': ')',
    '{': '}',
    '[': ']'
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (map.has(s[i])) stack.push(map[s[i]])
    else {
      if (s[i] !== stack.pop()) return false
    }
  }
  return stack.length === 0
}
```
## 21. Merge Two Sorted Lists  
[link](https://leetcode.com/problems/merge-two-sorted-lists/)  
```javascript
const mergeTwoLists = function(l1, l2) {
  const dummy = new ListNode(0)
  let cur = dummy
  while (l1 && l2) {
    if (l1.val < l2.val) {
      cur.next = l1
      l1 = l1.next
    } else {
      cur.next = l2
      l2 = l2.next
    }
    cur = cur.next
  }
  if (l1) cur.next = l1
  if (l2) cur.next = l2
  return dummy.next
}
```
## 22. Generate Parentheses  
[link](https://leetcode.com/problems/generate-parentheses/)  
```javascript
const generateParenthesis = function(n) {
  const res = []
  helper(0, 0, 0, '')
  return res

  function helper(left, right, level, tmp) {
    if (right > left || level > 2 * n) return
    else if (left === right && level === 2 * n) res.push(tmp.slice())
    else {
      helper(left + 1, right, level + 1, tmp + '(')
      helper(left, right + 1, level + 1, tmp + ')')
    }
  }
}
```
## 23. Merge k Sorted Lists  
[link](https://leetcode.com/problems/merge-k-sorted-lists/)  
```javascript
const mergeKLists = function(lists) {
  function merge(a, b) {
    let dummy = new ListNode(0)
    let cur = dummy
    while (a && b) {
      if (a.val < b.val) {
        cur.next = a
        a = a.next
      } else {
        cur.next = b
        b = b.next
      }
      cur = cur.next
    }
    if (a) cur.next = a
    if (b) cur.next = b
    return dummy.next
  }
  if (lists.length === 0) return null
  while (lists.length > 1) {
    let a = lists.pop()
    let b = lists.pop()
    let h = merge(a, b)
    lists.push(h)
  }
  return lists[0]
}
```
## 32. Longest Valid Parentheses  
[link](https://leetcode.com/problems/longest-valid-parentheses/)  
```javascript
const longestValidParentheses = function(s) {
  if (s.length <= 1) return 0
  let curMax = 0
  const dp = new Array(s.length).fill(0)
  for (let i = 1; i < s.length; i++) {
    if (s[i] == ')') {
      if (s[i - 1] == '(') {
        dp[i] = i >= 2 ? dp[i - 2] + 2 : 2
        curMax = Math.max(dp[i], curMax)
      } else {  // if s[i-1] == ')', combine the previous length.
        if (i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '(') {
          dp[i] = dp[i - 1] + 2 + ((i - dp[i - 1] - 2 >= 0) ? dp[i - dp[i - 1] - 2] : 0)
          curMax = Math.max(dp[i], curMax)
        }
      }
    } //else if s[i] == '(', skip it, because dp[i] must be 0
  }
  return curMax
}
```
## 33. Search in Rotated Sorted Array  
[link](https://leetcode.com/problems/search-in-rotated-sorted-array/)  
```javascript
const search = function(nums, target) {
  let lo = 0, hi = nums.length - 1
  while (lo <= hi) {
    let mid = lo + ((hi - lo) >> 1)
    if (nums[mid] === target) return mid
    if (nums[mid] > nums[hi]) {
      if (target < nums[mid] && target >= nums[lo]) hi = mid - 1
      else lo = mid + 1
    } else {
      if (target > nums[mid] && target <= nums[hi]>) lo = mid + 1
      else hi = mid - 1
    }
  }
  return -1
}
```
## 34. Find First and Last Position of Element in Sorted Array    
[link](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)  
```javascript
const searchRange = function(nums, target) {
  if (nums.length === 1) return target === nums[0] ? [0, 0] : [1, 1]
  let lo = 0, hi = nums.length
  while (lo < hi) {
    let mid = lo + ((hi - lo) >> 1)
    if (nums[mid] < target) lo = mid + 1
    else hi = mid
  }
  if (nums[lo] !== target) return [-1, -1]

  const res = []
  res.push(lo)
  while (nums[++lo] === target) {}
  res.push(lo - 1)
  return res
}
```
## 39. Combination Sum  
[link](https://leetcode.com/problems/combination-sum/)  
```javascript
const combinationSum = function(candidates, target) {
  const res = []
  helper(0, target, [])
  return res

  function helper(idx, left, tmp) {
    if (left < 0) return
    else if (left === 0) res.push(tmp.slice())
    else {
      for (let i = idx; i < candidates.length; i++) {
        // choose
        tmp.push(candidates[i])
        // explore
        helper(i, left - candidates[i], tmp)
        // un-choose
        tmp.pop()
      }
    }
  }
}
```
## 41. First Missing Positive  
[link](https://leetcode.com/problems/first-missing-positive/)  
```javascript
const firstMissingPositive = function(nums) {
  for (let i = 0; i < nums.length; i++) {
    while (nums[i] >= 1 && nums[i] <= nums.length && nums[i] !== nums[nums[i] - 1]) {
      swap(i, nums[i] - 1)
    }
  }
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== i + 1) return i + 1
  }
  return nums.length + 1
}
```
## 42. Trapping Rain Water  
[link](https://leetcode.com/problems/trapping-rain-water/)  
```javascript
const trap = function(heiget) {
  let maxl = 0, maxr = 0
  let l = 0, r = height.length - 1
  let max = 0
  while (l < r) {
    if (height[l] <= height[r]) {
      if (maxl < height[l]) maxl = height[l]
      else max += maxl - height[l]
      l++
    } else {
      if (maxr < height[r]) maxr = height[r]
      else max += maxr - height[r]
      r--
    }
  }
  return max
}
```
## 45. Jump Game II  
[link]()  
```javascript
const jump = function(nums) {
  let newMax = 0
  let jump = 0
  let oldMax = 0
  for (let i = 0; i < nums.length - 1; i++) {
    newMax = Math.max(newMax, i + nums[i])
    // before i reach oldMax, find the max that it could reach
    // i ~ oldMax is always one jump
    if (i == oldMax) {
      jump++
      oldMax = newMax
    }
  }
  return jump
}
```
## 46. Permutations  
[link](https://leetcode.com/problems/permutations/)  
```javascript
const permute = function(nums) {
  const res = []
  let data = nums
  helper(nums, [])
  return res
  
  function helper(left, tmp) {
    if (left.length === 0) res.push(tmp.slice())
    else {
      for (let i = 0; i < left.length; i++) {
        // choose
        tmp.push(left[i])
        const del = left.splice(i, 1)[0]
        // explore
        helper(left, tmp)
        // un-choose
        tmp.pop()
        left.splice(i, 0, del)
      }
    }
  }
}
```
## 48. Rotate Image  
[link](https://leetcode.com/problems/rotate-image/)  
```javascript
var rotate = function(matrix) {
  let m = matrix.length
  let n = matrix[0].length
  let midM = matrix.length >> 1
  for (let i = 0; i < midM; i++) {
    for (let j = 0; j < n; j++) {
      swap(i, j, m - i - 1, j)
    }
  }
  
  for (let i = 0; i < m; i++) {
    for (let j = i + 1; j < n; j++) {
      swap(i, j, j, i)
    }
  }
  
  function swap(x, y, m, n) {
    let tmp = matrix[x][y]
    matrix[x][y] = matrix[m][n]
    matrix[m][n] = tmp
  }
}
```
## 49. Group Anagrams  
[link](https://leetcode.com/problems/group-anagrams/)  
```javascript
const groupAnagrams = function(strs) {
  const map = {}
  for (let str of strs) {
    const key = [...str].sort().join('')
    if (!map[key]) map[key] = []
    map[key].push(str)
  }
  return Object.values(map)
}
```
## 53. Maximum Subarray  
[link](https://leetcode.com/problems/maximum-subarray/)  
```javascript
const maxSubArray = function(nums) {
  const dp = new Array(nums.length).fill(0)
  let sum = nums[0]
  dp[0] = nums[0]
  for (let i = 1; i < nums.length; i++) {
    dp[i] = dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i]
    sum = Math.max(dp[i], sum)
  }
  return sum
}
```
## 55. Jump Game  
[link](https://leetcode.com/problems/jump-game/)  
```javascript
const canJump = function(nums) {
    let reach = 0
  for (let i = 0; i <= reach; i++) {
    reach = Math.max(reach, i + nums[i])
    if (reach >= nums.length - 1) return true
  }
  return false
}
```
## 56. Merge Intervals  
[link](https://leetcode.com/problems/merge-intervals/)  
```javascript
const merge = function(intervals) {
  if (intervals.length < 2) return intervals
  intervals.sort((a, b) => a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1])
  let pre = intervals[0]
  let res = [pre]
  for (let cur of intervals) {
    if (cur[0] <= pre[1]) pre[1] = Math.max(pre[1], cur[1])
    else {
      res.push(cur)
      pre = cur
    }
  }
  return res
}
```
## 62. Unique Paths  
[link](https://leetcode.com/problems/unique-paths/)  
```javascript
const uniquePaths = function(m, n) {
  const dp = [...Array(m)].map(_ => Array(n).fill(1))
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1]
}
```
## 64. Minimum Path Sum  
[link](https://leetcode.com/problems/minimum-path-sum/)  
```javascript
const minPathSum = function(grid) {
  const dp = [...new Array(grid.length)].map(_ => new Array(grid[0].length).fill(0))
  dp[0][0] = grid[0][0]
  for (let i = 1; i < grid.length; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0] }
  for (let i = 1; i < grid[0].length; i++) { dp[0][i] = dp[0][i - 1] + grid[0][i] }
  for (let i = 1; i < grid.length; i++) {
    for (let j = 1; j < grid[0].length; j++) {
      dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])
    }
  }
  return dp[grid.length - 1][grid[0].length - 1]
}
```
## 70. Climbing Stairs  
[link](https://leetcode.com/problems/climbing-stairs/)  
```javascript
var climbStairs = function(n) {
  if (n < 2) return n
  let dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
  // memo
  if (n <= 0) return 0
  if (n === 1) return 1
  if (n === 2) return 2
  let oneStep = 2
  let twoStep = 1
  let sum = 0
  for (let i = 2; i < n; i++) {
    sum = oneStep + twoStep
    twoStep = oneStep
    oneStep = sum
  }
  return sum
}
```
## 72. Edit Distance  
[link](https://leetcode.com/problems/edit-distance/)  
```javascript
const minDistance = function(word1, word2) {
  let m = word1.length, n = word2.length
  const dp = [...new Array(m + 1)].map(_ => new Array(n + 1).fill(0)) 
  for (let i = 1; i <= m; i++) {
    dp[i][0] = i
  }
  for (let j = 1; j <= n; j++) {
    dp[0][j] = j
  }
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]
      // replace, delete, insert
      else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
    }
  }
  return dp[m][n]
}
```
## 75. Sort Colors  
[link](https://leetcode.com/problems/sort-colors/)  
```javascript
const sortColors = function(nums) {
  let lo = 0, hi = nums.length - 1
  for (let i = 0; i <= hi; i++) {
    if (nums[i] === 0) {
      [nums[i], nums[lo]] = [nums[lo], nums[i]]
      lo++
    } else if (nums[i] === 2) {
      [nums[i], nums[hi]] = [nums[hi], nums[i]]
      hi--
      // as before swap. nums[hi](which is nums[i] after swap) not checked, 
      // so i--, still the same i for check
      i--
    }
  }
}
```
## 78. Subsets  
[link](https://leetcode.com/problems/subsets/)  
```javascript
const subsets = function(nums) {
  const res = []
  helper(0, [])
  return res

  function helper(idx, tmp) {
    res.push(tmp.slice())
    for (let i = idx; i < nums.length; i++) {
      // choose
      tmp.push(nums[i])
      // explore
      helper(i + 1, tmp)
      // un-choose
      tmp.pop()
    }
  }
}
```
## 79. Word Search  
[link](https://leetcode.com/problems/word-search)  
```javascript
const exist = function(board, word) {
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      if (helper(i, j, 0)) return true
    }
  }
  return false

  function helper(idx, idy, path) {
    if (idx < 0 || idy < 0 || idx >= board.length || idy >= board[0].length 
    || board[idx][idy] !== word[path] || path > word.length) return false

    // choose
    board[idx][idy] = '*'
    path++

    // end-cond
    if (path === word.length) return true

    // explore
    let isFound = helper(idx + 1, idy, path) 
                || helper(idx - 1, idy, path)
                || helper(idx, idy + 1, path)
                || helper(idx, idy - 1, path)
    
    // un-choose
    board[idx][idy] = word[--path]

    return isFound

  }
}
```
## 94. Binary Tree Inorder Traversal  
[link](https://leetcode.com/problems/binary-tree-inorder-traversal/)  
```javascript
const inorderTraversal = function(root) {
  let res = []
  while (root) {
    if (!root.left) {
      res.push(root.val)
      root = root.right
    } else {
      let pre = root.left
      while (pre.right && pre.right != root) { pre = pre.right }
      if (!pre.right) {
        pre.right = root
        root = root.left
      } else {
        res.push(root.val)
        root = root.right
        pre.right = null
      }
    }
  }
  return res
}
```
## 95. Unique Binary Search Trees II  
[link](https://leetcode.com/problems/unique-binary-search-trees-ii/)  
[tips](https://leetcode.wang/leetCode-95-Unique-Binary-Search-TreesII.html#%E8%A7%A3%E6%B3%95%E4%B8%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)  
```javascript
const generateTrees = function (n) {
  if (n === 0) return []
  let dp = [...new Array(n + 1)].map(_ => [])
  dp[0].push(null)

  for (let len = 1; len <= n; len++) {
    for (let root = 1; root <= len; root++) {
      let l = root - 1, r = len - root
      dp[l].map(left => {
        dp[r].map(right => {
          let rt = new TreeNode(root)
          rt.left = left
          rt.right = clone(right, root)
          dp[len].push(rt)
        })
      })
    }
  }
  return dp[n]

  function clone(rt, delta) {
    if (!rt) return null
    let root = new TreeNode(rt.val + delta)
    root.left = clone(rt.left, delta)
    root.right = clone(rt.right, delta)
    return root
  }
}
```
## 96. Unique Binary Search Trees  
[link](https://leetcode.com/problems/unique-binary-search-trees/)  
```javascript
const bin = function(n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = dp[1] = 1
  for (let i = 2; i <= n; i++) {
    for (let j = 0; j < i; j++) {
      dp[i] += dp[j] * dp[i - j - 1]
    }
  }
  return dp[n]
}
```
## 98. Validate Binary Search Tree  
[link](https://leetcode.com/problems/validate-binary-search-tree/)  
```javascript
const isValidBST = function(root) {
  if (!root) return true
  let pre = null
  const stack = []
  
  while (stack.length || root) {
    while (root) {
      stack.push(root)
      root = root.left
    }
    root = stack.pop()
    if (pre && root.val <= pre.val) return false
    pre = root
    root = root.right
  }
  return true
}
```
## 101. Symmetric Tree  
[link](https://leetcode.com/problems/symmetric-tree/)  
```javascript
const isSymmetric = function(root) {
  // bfs
  if (!root) return true
  let stack = [[root.left, root.right]]
  while (stack.length) {
    let [l, r] = stack.shift()
    if (!l && !r) continue
    if (!l || !r || l.val !== r.val) return false
    stack.push([l.left, r.right])
    stack.push([l.right, r.left])
  }
  return true
  // dfs 
  if (!root) return true
  return isMirror(root.left, root.right)

  function isMirror(l, r) {
    if (!l || !r) return l == r
    return l.val === r.val && isMirror(l.left, r.right) && isMirror(l.right, r.left)
  }
}
```
## 102. Binary Tree Level Order Traversal  
[link](https://leetcode.com/problems/binary-tree-level-order-traversal/)  
```javascript
const levelOrder = function(root) {
  // bfs
  if (!root) return []
  let q = [root], res = []
  while (q.length) {
    let nxt = []
    let tmp = []
    while (q.length) {
      let cur = q.shift()
      tmp.push(cur.val)
      if (cur.left) nxt.push(cur.left)
      if (cur.right) nxt.push(cur.right)
    }
    res.push(tmp.slice())
    q = nxt
  }
  return res
  // dfs
  const res = []
  dfs(root, 0)
  return res
  
  function dfs(node, l) {
    if (!node) return
    if (!res[l]) res[l] = []
    res[l].push(node.val)
    dfs(node.left, l + 1)
    dfs(node.right, l + 1)
  }
}
```
## 104. Maximum Depth of Binary Tree  
[link](https://leetcode.com/problems/maximum-depth-of-binary-tree/)  
```javascript
const maxDepth = function(root) {
  // bfs
  if (!root) return 0
  let q = [root]
  let max = 0
  while (q.length) {
    const nxt = []
    while (q.length) {
      let cur = q.shift()
      if (cur.left) nxt.push(cur.left)
      if (cur.right) nxt.push(cur.right)
    }
    q = nxt
    max++
  }
  return max

  // dfs
  if (!root) return 0
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))
}
```
## 105. Construct Binary Tree from Preorder and Inorder Traversal  
[link](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)  
```javascript
const buildTree = function(preorder, inorder) {
  return build(0, inorder.length - 1)

  function build(l, r) {
    if (l > r) return null
    let p = preorder.shift()
    let i = inorder.indexOf(p)
    let node = new TreeNode(p)

    node.left = build(l, i - 1)
    node.right = build(i + 1, r)
    return node
  }
}
```
## 114. Flatten Binary Tree to Linked List  
[link](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)  
```javascript
const flatten = function(root) {
  let cur = root
  while (cur) {
    if (cur.left) {
      let pre = cur.left
      while (pre.right) { pre = pre.right }
      pre.right = cur.right
      cur.right = cur.left
      cur.left = null
    }
    cur = cur.right
  }
}
```
## 121. Best Time to Buy and Sell Stock  
[link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)  
```javascript
const maxProfit = function(prices) {
  let max = 0
  let lo = prices[0]
  for (let p of prices) {
    max = Math.max(max, p - lo)
    lo = Math.min(p, lo)
  }
  return max
}
```
## 124. Binary Tree Maximum Path Sum  
[link](https://leetcode.com/problems/binary-tree-maximum-path-sum/)  
```javascript
const maxPathSum = function(root) {
  let max = -Infinity
  dfs(root)
  return max

  function dfs(node) {
    if (!node) return 0
    let l = Math.max(0, dfs(node.left))
    let r = Math.max(0, dfs(node.right))
    max = Math.max(max, l + r + node.val)
    return Math.max(l, r) + node.val
  }
}
```
## 128. Longest Consecutive Sequence  
[link](https://leetcode.com/problems/longest-consecutive-sequence/)  
```javascript
const longestConsecutive = function(nums) {
  let set = new Set(nums)
  let cur = 0, max = 0
  for (let num of nums) {
    if (!set.has(num - 1)) {
      let tmp = num
      while (set.has(tmp++)) { cur++ }
      max = Math.max(max, cur)
    }
    cur = 0
  }
  return max
}
```
## 136. Single Number  
[link](https://leetcode.com/problems/single-number/)  
```javascript
const singleNumber = function(nums) {
  let res = nums[0]
  for (let i = 1; i < nums.length; i++) {
    res ^= res[i]
  }
  return res
}
```
## 138. Copy List with Random Pointer  
[link](https://leetcode.com/problems/copy-list-with-random-pointer/)  
```javascript
const copyRandomList = function(head) {
  let pointer = head
  let next = null

  while (pointer) {
    next = pointer.next
    let copy = new ListNode(pointer.val)
    pointer.next = copy
    copy.next = next
    pointer = next
  }

  pointer = head
  while (pointer) {
    if (pointer.random) {
      pointer.next.random = pointer.random.next
    }
    pointer = pointer.next.next
  }

  pointer = head
  let dummy = new ListNode(0)
  let copy = null
  let copyPre = dummy
  while (pointer) {
    next = pointer.next.next
    // extract copy
    copy = pointer.next
    copyPre.next = copy
    copyPre = copy
    // restore
    pointer.next = next
    pointer = next
  }
  return dummy.next
}
```
## 139. Word Break  
[link](https://leetcode.com/problems/word-break/)  
```javascript
const wordBreak = function(s, wordDict) {
  // dp[i] means whether s[0, i] could be sperated by words in wordDict
  const dp = new Array(s.length + 1).fill(false)
  dp[0] = true
  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) >= 0) {
        dp[i] = true
        break
      }
    }
  }
  return dp[s.length]
}
```
## 141. Linked List Cycle  
[link](https://leetcode.com/problems/linked-list-cycle/)  
```javascript
const hasCycle = function(head) {
  let slow = head
  let fast = head

  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (slow == fast) return true
  }
  return false
}
```
## 142. Linked List Cycle II  
[link](https://leetcode.com/problems/linked-list-cycle-ii/)  
```javascript
const detectCycle = function(head) {
  let slow = head
  let fast = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast == slow) {
      let tool = head
      while (tool != slow) {
        tool = tool.next
        slow = slow.next
      }
      return tool
    }
  }
  return null
}
```
## 146. LRU Cache  
[link](https://leetcode.com/problems/lru-cache)  
```javascript
let Node = function(key, val) {
  this.key = key
  this.val = val
  this.prev = this.tail = null
}
let DoublyLinkedList = function() {
  this.head = new Node(null, null)
  this.tail = new Node(null, null)
  this.head.next = this.tail
  this.tail.prev = this.head
}
DoublyLinkedList.prototype.insertHead = function(node) {
  node.prev = this.head
  node.next = this.head.next
  this.head.next.prev = node
  this.head.next = node
}
DoublyLinkedList.prototype.removeNode = function(node) {
  node.prev.next = node.next
  node.next.prev = node.prev
}
DoublyLinkedList.prototype.moveToHead = function(node) {
  this.removeNode(node)
  this.insertHead(node)
}
DoublyLinkedList.prototype.removeTail = function() {
  let tail = this.tail.prev
  this.removeNode(tail)
  return tail.key
}
const LRUCache = function(capacity) {
  this.capacity = capacity
  this.currentSize = 0
  this.hash = new Map()
  this.dll = new DoublyLinkedList()
}
LRUCache.prototype.get = function(key) {
  let node = this.hash.get(key)
  if (!node) return -1
  this.dll.moveToHead(node)
  return node,val
}
LRUCache.prototype.put = function(key, value) {
  let node = this.has.get(key)
  if (!node) {
    let newNode = new Node(key, value)
    this.has.set(key, value)
    this.dll.insertToHead(newNode)
    this.currentSize++
    if (this.currentSize > this.capacity) {
      let tailKey = this.removeTail()
      this.hash.delete(tailKey)
      this.currentSize-- 
    }
  } else {
    node.val = value
    this.dll.moveToHead(node)
  }
}
```
## 148. Sort List  
[link](https://leetcode.com/problems/sort-list/)  
```javascript
const sortList = function(head) {
  if (!head || !head.next) return head
  let fast = head
  let slow = head
  while (fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
  }
  let mid = slow.next
  slow.next = null
  
  let dummy = new ListNode(0)
  let cur = dummy
  let left = sortList(head)
  let right = sortList(mid)
  while (left && right) {
    if (left.val < right.val) {
      cur.next = left
      left = left.next
    } else {
      cur.next = right
      right = right.next
    }
    cur = cur.next
  }
  cur.next = left | right
  return dummy.next
}
```
## 152. Maximum Product Subarray  
[link](https://leetcode.com/problems/maximum-product-subarray/)  
```javascript
const maxProduct = function(nums) {
  let preMin = preMax = max = nums[0]
  for (let i = 1; i < nums.length; i++) {
    let curMax = Math.max(preMax * nums[i], nums[i], preMin * nums[i])
    let curMin = Math.min(preMax * nums[i], nums[i], preMin * nums[i])

    preMax = curMax
    preMin = curMin
    max = Math.max(max, curMax)
  }
  return max
}
```
## 155. Min Stack  
[link](https://leetcode.com/problems/min-stack/)  
```javascript
var MinStack = function() {
  this.stack = []
}
MinStack.prototype.push = function(x) {
  let min = this.stack.length === 0 ? x : this.stack[this.stack.length - 1].min
  this.stack.push({val: x, min: Math.min(x, min)})
}
MinStack.prototype.pop = function() {
  if (this.stack.length) this.stack.pop()
}
MinStack.prototype.top = function() {
  if (this.stack.length) return this.stack[this.stack.length - 1].val
    
}

MinStack.prototype.getMin = function() {
  if (this.stack.length) return this.stack[this.stack.length - 1].min 
}
```
## 160. Intersection of Two Linked Lists  
[link](https://leetcode.com/problems/intersection-of-two-linked-lists/)  
```javascript
const getIntersectionNode = function(headA, headB) {
  let a = headA
  let b = headB
  while (a !== b) {
    a = a ? a.next : headB
    b = b ? b.next : headA
  }
  return a
}
```
## 198. House Robber  
[link](https://leetcode.com/problems/house-robber/)  
```javascript
const rob = function(nums) {
  let preMax = curMax = 0
  for (let num of nums) {
    let tmp = curMax
    curMax = Math.max(curMax, preMax + num)
    preMax = tmp
  }
  return Math.max(curMax, preMax)
}
```
## 200. Number of Islands  
[link](https://leetcode.com/problems/number-of-islands/)  
```javascript
const numIsLand = function(grid) {
  if (!grid || !grid.length || !grid[0].length) return 0
  const m = grid.length, n = grid[0].length
  let num = 0
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] == 1) {
        dfs(i, j)
        num++
      }
    }
  }
  return num

  function dfs(x, y) {
    grid[x][y] = '0'
    const directions = [-1, 0, 1, 0, -1]
    for (let i = 0; i < directions.length - 1; i++) {
      let newX = x + directions[i]
      let newY = y + directions[i + 1]
      if (!outOfBound(newX, newY) && grid[newX][newY] == 1) dfs(newX, newY)
    }
  }

  function outOfBound(x, y) {
    return x < 0 || y < 0 || x >= m || y >= n
  }
}
```
## 206. Reverse Linked List  
[link](https://leetcode.com/problems/reverse-linked-list/)  
```javascript
const reverseList = function(head) {
  let prev = null
  while (head) {
    let next = head.next
    head.next = prev
    prev = head
    head = next
  }
  return prev
}
```
## 207. Course Schedule  
[link](https://leetcode.com/problems/course-schedule/)  
```javascript
const canFinish = function(numCourses, prerequisites) {
  const seen = new SEt()
  const seeing = new Set()
  const adj = [...Array(numCourses)].map(_ => [])
  for (let [u, v] of prerequisites) { adj[v].push(u) }
  for (let c = 0; c < numsCourses; c++) { if (!dfs(c)) return false}
  return true

  function dfs(v) {
    if (seen.has(v)) return true
    if (seeing.has(v)) return false

    // choose
    seeing.add(v)
    // explore
    for (let nv of adj[v]) {
      if (!dfs(nv)) return false
    }
    // un-choose
    seeing.delete(v)
    seen.add(v)
    return true
  }
}
```
## 212. Word Search II(//TODO)  
[link](https://leetcode.com/problems/word-search-ii/)  
```javascript
const findWords = function(board, word) {
  const res = []
  const root = buildTrie()
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      search(root, i, j)
    }
  }
  return res

  function buildTrie() {
    const root = {}
    for (let w of words) {
      let node = root
      for (let c of w) {
        if (node[c] == null) node[c] = {}
        node = node[c]
      }
      node.word = w
    }
    return root
  }

  function search(node, i, j) {
    if (node.word != null) {
      res.push(node.word) 
      node.word = null
    }
     if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) return
    if (node[board[i][j]] == null) return 
    
    // choose
    const c = board[i][j]
    board[i][j] = '#'
    // explore
    search(node[c], i + 1, j)
    search(node[c], i - 1, j)
    search(node[c], i, j + 1)
    search(node[c], i, j - 1)
    // un-choose
    board[i][j] = c
  }
}
```
## 215. Kth Largest Element in an Array  
[link](https://leetcode.com/problems/kth-largest-element-in-an-array/)  
```javascript
const findKthLargest = function(nums, k) {
  k = nums.length - k
  let lo = 0, hi = nums.length - 1
  while (lo <= hi) {
    let j = partition(lo, hi, nums) 
    if (j < k) lo = j + 1
    else if (j > k) hi = j - 1
    else break
  }
  return nums[k]

  function partition(lo, hi, nums) {
    let i = lo, j = hi + 1
    while (true) {
      // find nums[i] large than pivot
      while (i < hi && nums[++i] < nums[lo]) {}
      // find nums[j] less than pivot
      while (j > lo && nums[--j] > nums[lo]) {}
      if (i >= j) break
      swap(i, j)
    }
    swap(lo, j)
    return j
  }
}
```
## 221. Maximal Square  
[link](https://leetcode.com/problems/maximal-square/)  
```javascript
const maximalSquare = function(matrix) {
  if (!matrix || !matrix.length || !matrix[0].length) return 0
  const dp = [...new Array(matrix.length)].map(_ => new Array(matrix[0].length).fill(0))
  let max = 0
  for (let i = 1; i <= matrix.length; i++) {
    for (let j = 1; j<= matrix[0].length; j++) {
      if (matrix[i - 1][j - 1] == 1) {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
        max = Math.max(max, dp[i][j])
      }
    }
  }
  return max * max
}
```
## 230. Kth Smallest Element in a BST  
[link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  
```javascript
const kthSmallest = function(root, k) {
  let res = 0
  let cnt = 0
  traverse(root)
  return res

  function traverse(node) {
    if (!node) return
    traverse(node.left)
    cnt++
    if (cnt === k) return res = node.val
    traverse(node.right)
  }
}
```
## 234. Palindrome Linked List  
[link](https://leetcode.com/problems/palindrome-linked-list/)  
```javascript
const isPalindrome = function(head) {
  if (!head) return true
  let slow = head
  let fast = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
  }
  let half = reverse(slow)
  while (head && half) {
    if (head.val !== half.val) return false
    head = head.next
    half = half.next
  }
  return true

  function reverse(node) {
    let prev = null
    while (node) {
      let next = node.next
      node.next = prev
      prev = node
      node = next
    }
    return prev
  }
}
```
## 236. Lowest Common Ancestor of a Binary Tree  
[link](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)  
```javascript
const lowestCommonAncestor = function(root, p, q) {
  // dfs
  if (!root || root == q || root = p) return root
  let l = lowestCommonAncestor(root.left, p, q)
  let r = lowestCommonAncestor(root.right, p, q)
  return (l && r) ? root : l || r
  // map
  let parent = new Map()
  const stack = [root]
  parent.set(root, null)
  
  // find p and q's 
  while (!parent.has(p) || !parent.has(q)) {
    let node = stack.pop()
    if (node.left) {
      parent.set(node.left, node)
      stack.push(node.left)
    }
    if (node.right) {
      parent.set(node.right, node)
      stack.push(node.right)
    }
  }
  const ancestor = new Set()
  while (p != null) {
    ancestor.add(p)
    p = parent.get(q)
  }
  while (!ancestor.has(q)) { q = parent.get(q) }
  return q
}
```
## 238. Product of Array Except Self  
[link](https://leetcode.com/problems/product-of-array-except-self/)  
```javascript
const productExceptSelf = function(nums) {
  const res = new Array(nums.length).fill(1)
  // from left to right
  for (let i = 1; i < nums.length; i++) { res[i] = res[i - 1] * nums[i - 1] }
  let right = 1
  // from right to left
  for (let i = nums.length - 1; i >= 0; i--) {
    res[i] *= right
    right *= nums[i]
  }
  return res
}
```
## 240. Search a 2D Matrix II  
[link](https://leetcode.com/problems/search-a-2d-matrix-ii/)  
```javascript
const searchMatrix = function(matrix, target) {
  if (!matrix || !matrix.length || !matrix[0].length) return false
  let idx = 0, idy = matrix[0].length - 1
  while (idx < matrix.length && idy >= 0) {
    if (matrix[idx][idy] == target) return true
    if (matrix[idx][idy] > target) idy--
    else idx++
  }
  return false
}
```
## 253. Meeting Rooms II  
[link](https://leetcode.com/problems/meeting-rooms-ii/)  
```javascript
const minMeetingRooms = function(intervals) {
  if (!intervals.length) return 0
  let start = intervals.slice().sort((a, b) => a[0] - b[0])
  let ends = intervals.sort((a, b) => a[1] - b[1])
  let end = 0
  let rooms = 0
  for (let i = 0; i < intervals.length; i++) {
    if (starts[i][0] < ends[end][1]) rooms++
    else end++
  }
  return rooms

}
```
## 279. Perfect Squares  
[link](https://leetcode.com/problems/perfect-squares/)  
```javascript
const numSquares = function(n) {
  const dp = new Array(n + 1).fill(Infinity)
  dp[0] = 0
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j * j <= i; j++) {
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1)
    }
  }
  return dp[n]
}
```
## 283. Move Zeroes  
[link](https://leetcode.com/problems/move-zeroes/)  
```javascript
const moveZeros = function(nums) {
  let idx = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      nums[idx] = nums[i]
      nums[i] = i === idx ? nums[idx] : 0
      idx++
    }
  }
}
```
## 287. Find the Duplicate Number  
[link](https://leetcode.com/problems/find-the-duplicate-number/)  
```javascript
const findDuplicate = function(nums) {
  let lo = 1, hi = nums.length
  while (lo < hi) {
    let mid = lo + ((hi - lo) >> 1)
    let cnt = 0
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] <= mid) cnt++
    }
    if (cnt > mid) hi = mid // duplicate in [lo, mid]
    else lo = mid + 1  // duplicate in [mid + 1, hi]
  }
  return lo
}
```
## 297. Serialize and Deserialize Binary Tree  
[link](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)  
```javascript
const serialize = function(root) {
  const data = []
  return dfs(root)

  function dfs(node) {
    if (!node) data.push(null)
    else {
      data.push(node.val)
      dfs(node.left)
      dfs(node.right)
    }
    return data
  }
}
const deserialize = function(data) {
  return helper()

  function helper() {
    if (!data.length) return
    let cur = data.shift()
    if (cur == null) return null
    node.left = helper()
    node.right = helper()
    return node
  }
}
```
## 300. Longest Increasing Subsequence  
[link](https://leetcode.com/problems/longest-increasing-subsequence/)  
```javascript
const lengthOfLIS = function(nums) {
  let tails = new Array(nums.length).fill(0)
  let max = 0
  for (let num of nums) {
    let i = 0, j = max
    // search for the pos of num in tails
    while (i < j) {
      let mid = i + ((j - i) >> 1)
      if (hum > tails[mid]) lo = mid + 1
      else j = mid
    }
    // update tails
    tails[i] = num
    if (max === i) max++
  }
  return max
}

```
## 301. Remove Invalid Parentheses(//TODO)  
[link](https://leetcode.com/problems/remove-invalid-parentheses/)  
```javascript
const removeInvalidParentheses = function(s) {
  // dfs
  if (!s) return ['']
  let res = []
  let l = 0, r = 0
  for (let i = 0; i < s.length; i++) {
    if (s[i] == '(') l++
    else if (s[i] == ')') {
      if (l > 0) l--
      else r++
    }
  }
  dfs(s, res, '', 0, l, r, 0)
  return res
  
  function dfs(s, res, tmp, pos, l, r, open) {
    if (l < 0 || r < 0 || open < 0) return
    
    if (pos === s.length) {
      if (l == 0 && r == 0 && open == 0) {
        if (!res.includes(tmp)) res.push(tmp)
      }
      return
    }
    if (s[pos] == '(') {
      dfs(s, res, tmp + '(', pos + 1, l, r, open + 1) // use
      dfs(s, res, tmp, pos + 1, l - 1, r, open) // not use
    } else if (s[pos] === ')') {
      dfs(s, res, tmp + ')', pos + 1, l, r, open - 1) // use
      dfs(s, res, tmp, pos + 1, l, r - 1, open) // not use
    } else {
      dfs(s, res, tmp + s[pos], pos + 1, l, r, open)
    }
  }
}
```
## 309. Best Time to Buy and Sell Stock with Cooldown  
[link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)  
```javascript
const maxProfit = function(prices) {
  let preBuy = 0, buy = -prices[0], preSell = 0, sell = 0
  for (let p of prices) {
    preBuy = buy
    buy = Math.max(preSell - p, preBuy)
    preSell = sell
    sell = Math.max(preSell, preBuy + p)
  }
  return sell
}
```
## 322. Coin Change  
[link](https://leetcode.com/problems/coin-change/)  
```javascript
const coinChange = function(coins, amount) {
  const dp = new Array(amount + 1).fill(amount + 1)
  dp[0] = 0
  for (let c of coins) {
    for (let i = c; i <= amount; i++) {
      dp[i] = Math.min(dp[i], dp[i - c] + !)
    }
  }
  return dp[amount] === amount + 1 ? -1 : dp[amount]
}
```
## 337. House Robber III  
[link](https://leetcode.com/problems/house-robber-iii/)  
```javascript
const rob = function(root) {
  return Math.max(...dfs(root))

  function dfs(node) {
    if (!node) return [0, 0]
    let l = dfs(node.left)
    let r = dfs(node.right)
    let cur = node.val + l[1] + r[1]
    let nxt = Math.max(l[0], l[1]) + Math.max(r[0], r[1])
    return [cur, nxt]
  }
}
```
## 338. Counting Bits  
[link](https://leetcode.com/problems/counting-bits/)  
```javascript
const countBits = function(num) {
  const dp = new Array(num + 1).fill(0)
  for (let i = 1; i <= num; i++) {
    dp[i] = dp[i & (i - 1)] + 1
  }
  return dp
}
```
## 347. Top K Frequent Elements  
[link](https://leetcode.com/problems/top-k-frequent-elements/)  
```javascript
const topKFrequent = function(nums, k) {
  const bucketSize = nums.length + 1
  const map = new Map()
  const buckets = [...new Array(bucketSize)].map(_ => []) 
  for (let num of nums) {
    map[num] = ~~map[num] + 1
  }
  for (let num in map) {
    buckets[map[num]].push(num | 0)
  }
  const res = []
  for (let i = bucketSize - 1; i >= 0 && k > 0; k--) {
    while (buckets[i].length === 0) { i-- }
    res.push(buckets[i].pop())
  } 
  return res
}
```
## 394. Decode String  
[link](https://leetcode.com/problems/decode-string/)  
```javascript
const decodeString = function(s) {
  const stack = [[1, '']]
  for (let i = 0; i < s.length; i++) {
    if (isDigit(s[i])) {
      const numStr = parseNumber(s, i)
      stack.push([parseInt(numStr), ''])
      i += numStr.length - 1
    } else if (s[i] === '[') {
      continue
    } else if (s[i] === ']') {
      const [nRepeats, str] = stack.pop()
      const top = stack[stack.length - 1]
      top[1] += str.repeat(nRepeats)
    } else {
      const top = stack[stack.length - 1]
      top[1] += s[i]
    }
  }
  const [nRepeats, str] = stack.pop()
  return str
  
  function isDigit(c) { return /[0-9]/.test(c) }
  function parseNumber(s, start) {
    let i = start
    while (isDigit(s[i])) { i++ }
    return s.substring(start, i)
  }
}
```
## 416. Partition Equal Subset Sum  
[link](https://leetcode.com/problems/partition-equal-subset-sum/)  
```javascript
const canParition = function(nums) {
  let sum = nums.reduce((total, num) => total + num)
  if (sum & 1) return false
  let half = sum / 2 
  const dp = new Array(half + 1).fill(false)
  dp[0] = true
  for (let num of nums) {
    for (let i = half; i >= num; i--) {
      if (dp[i - num]) dp[i] = dp[i - num]
      if (dp[half]) return true
    }
  }
  return dp[half]
}
```
## 437. Path Sum III  
[link](https://leetcode.com/problems/path-sum-iii)  
```javascript
const pathSum = function(root, sum) {
  if (!root) return 0
  return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum)

  function dfs(node, target) {
    if (!node) return 0
    return (node.val == sum ? 1 : 0) + dfs(node.left, sum - node.val) + dfs(node.right, sum - node.val)
  }
}
```
## 438. Find All Anagrams in a String  
[link](https://leetcode.com/problems/find-all-anagrams-in-a-string/)  
```javascript
const findAnagrams = function(s, p) {
  let unique = 0
  let map = new Map()
  for (let c of p) {
    if (map[c] == null) {
      unique++
      map[c] = 1
    } else map[c]++
  }
  let lo = 0, hi = 0
  const res = []
  for (hi; hi < s.length; hi++) {
    if (map[s[hi]] != null) map[s[hi]]--
    if (map[s[hi]] == 0) unique--
    if (unique === 0) res.push(lo)
    if (hi - lo + 1 === p.length) {
      if (map[s[lo]] != null) map[s[lo]]++
      if (map[s[lo++]] === 1) unique++
    }
  }
  return res
}
```
## 448. Find All Numbers Disappered in an Array  
[link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)  
```javascript
const findDisappearedNumbers = function(nums) {
  const res = []
  for (let i = 0; i < nums.length; i++) {
    let idx = Math.abs(nums[i]) - 1
    nums[idx] = nums[idx] > 0 ? -nums[idx] : nums[idx]
  }
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > 0) res.push(i + 1)
  }
  return res
}
```
## 494. Target Sum  
[link](https://leetcode.com/problems/target-sum/)  
```javascript
const findTargetSumWays = function(nums, S) {
  let sum = 0 
  for (let num of nums) {sum += num}
  if (sum < S || -sum > S) return 0
  let dp = Array(2 * sum + 1).fill(0)
  dp[0 + sum] = 1
  for (let i = 0; i < nums.length; i++) {
    let next = new Array(2 * sum + 1).fill(0)
    for (let k = 0; k < 2 * sum + 1; k++) {
      if (dp[k] != 0) {
        next[k + nums[i]] += dp[k]
        next[k - nums[i]] += dp[k]
      }
    }
    dp = next
  }
  return dp[sum + S]
  
  /*
  //dfs
  return dfs(0, 0)

  function dfs(cur, idx) {
    if (idx === nums.length) return cur === S ? 1 : 0
    else if (idx < nums.length) {
      let l = cur + nums[idx]
      let r = cur - nums[idx]
      return dfs(l, idx + 1) + dfs(r, idx + 1)
    }
  }
  */
}
```
## 543. Diameter of Binary Tree  
[link](https://leetcode.com/problems/diameter-of-binary-tree/)  
```javascript
const diameterOfBinaryTree = function(root) {
  if (!root) return 0
  let max = 0
  dpt(root)
  return max
  
  function dpt(node) {
    if (!node) return 0
    let l = dpt(node.left)
    let r = dpt(node.right)
    
    max = Math.max(l + r, max)
    return 1 + Math.max(l, r)
  }
}
```
## 560.  Subarray Sum Equals K  
[link](https://leetcode.com/problems/subarray-sum-equals-k/)  
```javascript
const subarraySum = function(nums, k) {
  let cnt = 0
  let sum = 0
  let map = new Map()
  map.set(0, 1)
  
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i]
    if (map.has(sum - k)) cnt += map.get(sum - k)
    if (map.has(sum)) map.set(sum, map.get(sum) + 1)
    else map.set(sum, 1)
  }
  return cnt
}
```
## 581. Shortest Unsorted Continuous Subarray  
[link](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/)  
```javascript
const findUnsortedSubarray = function(nums) {
  let n = nums.length
  let lo = -1, hi = -2
  let min = nums[n - 1], max = nums[0]
  for (let i = 1; i < n; i++) {
    max = Math.max(nums[i], max)
    min = Math.min(nums[n - i - 1], min)
    // after hi is in order
    if (nums[i] < max) hi = i
    // before lo is in order
    if (nums[n - i - 1] > min) lo = n - i - 1
  }
  return hi - lo + 1
}
```
## 617. Merge Two Binary Trees  
[link](https://leetcode.com/problems/merge-two-binary-trees/)  
```javascript
const mergeTrees = function(t1, t2) {
  // dfs
  if (!t1 && !t2) return null
  let val = (t1 ? t1.val : 0) + (t2 ? t2.val : 0)
  let node = new TreeNode(val)
  node.left = mergeTrees(t1 && t1.left, t2 && t2.left)
  node.right = mergeTrees(t1 && t1.right, t2 && t2.right)
  return node
  // bfs
  if (!t1 || !t2) return t1 || t2
  let stack = []
  stack.push([t1, t2])
  
  while (stack.length) {
    let [n1, n2] = stack.shift()
    // n1 will not be null
    if (!n2) continue
    n1.val += n2.val
    if (!n1.left) n1.left = n2.left
    else stack.push([n1.left, n2.left])
    if (!n1.right) n1.right = n2.right
    else stack.push([n1.right, n2.right])
  }
  return t1
  

```
## 647. Palindromic Substring  
[link](https://leetcode.com/problems/palindromic-substrings/)  
```javascript
const countSubstrings = function(s) {

  if (s.length === 0) return 0
  let cnt = 1
  for (let i = 0; i < s.length - 1; i++) {
    check(i, i)
    check(i, i + 1)
  }
  return cnt

  function check(i, j) {
    while (i >= 0 && j < s.length && s[i] == s[j]) {
      cnt++
      i--
      j++
    }
  }
  // dp
  const len = s.length
  const dp = [...Array(len)].map(_ => Array(len).fill(false)) 
  let cnt = 0
  for (let i = len - 1; i >= 0; i--) {
    for (let j = i; j < len; j++) {
      dp[i][j] = s[i] === s[j] && (j - i < 3 || dp[i + 1][j - 1])
      if (dp[i][j]) cnt++
    }
  }
  return cnt
}
```
## 739. Daliy Temperatures  
[link](https://leetcode.com/problems/daily-temperatures/)  
```javascript
const dailyTemperatures = function(T) {
  const stack = []
  let res = new Array(T.length).fill(0)
  for (let i = 0; i < T.length; i++) {
    while (stack.length && T[i] > T[stack[stack.length - 1]]) {
      let idx = stack.pop()
      res[idx] = i - idx
    }
    stack.push(i)
  }
  return res
}
```
